using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TaskAgent.Tasks.Domain.Enums;
using TaskAgent.Tasks.Domain.Exceptions;

namespace TaskAgent.Tasks.Domain.Entities;

/// <summary>
/// Represents an intelligent recommendation for task management actions.
/// Generated by the agent's policy to suggest optimal task handling.
/// </summary>
public sealed class TaskRecommendation
{
    /// <summary>
    /// Gets the unique identifier for this recommendation.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the ID of the task this recommendation applies to.
    /// </summary>
    public Guid TaskId { get; private set; }

    /// <summary>
    /// Gets the recommended action to take on the task.
    /// </summary>
    public string RecommendedAction { get; private set; }

    /// <summary>
    /// Gets the reasoning behind this recommendation.
    /// </summary>
    public string Reasoning { get; private set; }

    /// <summary>
    /// Gets the confidence score for this recommendation (0.0 to 1.0).
    /// </summary>
    public double ConfidenceScore { get; private set; }

    /// <summary>
    /// Gets the recommended priority if the action involves priority changes.
    /// </summary>
    public TaskPriority? RecommendedPriority { get; private set; }

    /// <summary>
    /// Gets the recommended snooze duration if the action is to snooze.
    /// </summary>
    public TimeSpan? RecommendedSnoozeDuration { get; private set; }

    /// <summary>
    /// Gets the timestamp when this recommendation was generated.
    /// </summary>
    public DateTimeOffset GeneratedAt { get; private set; }

    /// <summary>
    /// Gets the timestamp when this recommendation expires and should no longer be used.
    /// </summary>
    public DateTimeOffset ExpiresAt { get; private set; }

    /// <summary>
    /// Gets whether this recommendation has been applied to the task.
    /// </summary>
    public bool IsApplied { get; private set; }

    /// <summary>
    /// Gets the timestamp when this recommendation was applied, if applicable.
    /// </summary>
    public DateTimeOffset? AppliedAt { get; private set; }

    /// <summary>
    /// Private constructor for ORM/serialization use.
    /// </summary>
    private TaskRecommendation()
    {
        RecommendedAction = string.Empty;
        Reasoning = string.Empty;
    }

    /// <summary>
    /// Creates a new task recommendation.
    /// </summary>
    /// <param name="taskId">The ID of the task this recommendation applies to.</param>
    /// <param name="recommendedAction">The action to recommend. Cannot be null or whitespace.</param>
    /// <param name="reasoning">The reasoning for the recommendation. Cannot be null or whitespace.</param>
    /// <param name="confidenceScore">The confidence score (0.0 to 1.0).</param>
    /// <param name="validityDuration">How long this recommendation remains valid.</param>
    /// <param name="recommendedPriority">Optional recommended priority.</param>
    /// <param name="recommendedSnoozeDuration">Optional recommended snooze duration.</param>
    /// <exception cref="ArgumentException">Thrown when parameters are invalid.</exception>
    public TaskRecommendation(
        Guid taskId,
        string recommendedAction,
        string reasoning,
        double confidenceScore,
        TimeSpan validityDuration,
        TaskPriority? recommendedPriority = null,
        TimeSpan? recommendedSnoozeDuration = null)
    {
        if (taskId == Guid.Empty)
            throw new ArgumentException("Task ID cannot be empty.", nameof(taskId));

        if (string.IsNullOrWhiteSpace(recommendedAction))
            throw new ArgumentException("Recommended action cannot be null or whitespace.", nameof(recommendedAction));

        if (string.IsNullOrWhiteSpace(reasoning))
            throw new ArgumentException("Reasoning cannot be null or whitespace.", nameof(reasoning));

        if (confidenceScore < 0.0 || confidenceScore > 1.0)
            throw new ArgumentOutOfRangeException(nameof(confidenceScore), "Confidence score must be between 0.0 and 1.0.");

        if (validityDuration <= TimeSpan.Zero)
            throw new ArgumentException("Validity duration must be positive.", nameof(validityDuration));

        if (recommendedSnoozeDuration.HasValue && recommendedSnoozeDuration.Value <= TimeSpan.Zero)
            throw new ArgumentException("Snooze duration must be positive if specified.", nameof(recommendedSnoozeDuration));

        Id = Guid.NewGuid();
        TaskId = taskId;
        RecommendedAction = recommendedAction.Trim();
        Reasoning = reasoning.Trim();
        ConfidenceScore = confidenceScore;
        RecommendedPriority = recommendedPriority;
        RecommendedSnoozeDuration = recommendedSnoozeDuration;
        GeneratedAt = DateTimeOffset.UtcNow;
        ExpiresAt = GeneratedAt.Add(validityDuration);
        IsApplied = false;
    }

    /// <summary>
    /// Marks this recommendation as applied to the task.
    /// </summary>
    /// <exception cref="InvariantViolationException">Thrown when recommendation is already applied or expired.</exception>
    public void MarkAsApplied()
    {
        if (IsApplied)
            throw new InvariantViolationException("Recommendation has already been applied.");

        if (IsExpired())
            throw new InvariantViolationException("Cannot apply an expired recommendation.");

        IsApplied = true;
        AppliedAt = DateTimeOffset.UtcNow;
    }

    /// <summary>
    /// Checks if this recommendation has expired and should no longer be used.
    /// </summary>
    public bool IsExpired()
    {
        return DateTimeOffset.UtcNow >= ExpiresAt;
    }

    /// <summary>
    /// Checks if this recommendation is still valid (not expired and not applied).
    /// </summary>
    public bool IsValid()
    {
        return !IsExpired() && !IsApplied;
    }

    /// <summary>
    /// Checks if the confidence score meets a minimum threshold.
    /// </summary>
    /// <param name="threshold">The minimum confidence threshold (0.0 to 1.0).</param>
    public bool MeetsConfidenceThreshold(double threshold)
    {
        if (threshold < 0.0 || threshold > 1.0)
            throw new ArgumentOutOfRangeException(nameof(threshold), "Threshold must be between 0.0 and 1.0.");

        return ConfidenceScore >= threshold;
    }
}